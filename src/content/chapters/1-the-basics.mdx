---
chapter: 1
title: O "básico"
shortname: Básico
slug: the-basics
updatedAt: 2023-07-19T18:57:54.630Z
---

<!-- The one thing that surprised me over and over again while writing this article was how *simple* computers are. It's still hard for me not to psych myself out, expecting more complexity or abstraction than actually exists! If there's one thing you should burn into your brain before continuing, it's that everything that seems simple actually is that simple. This simplicity is very beautiful and sometimes very, very cursed. -->

Uma coisa que me surpreendeu várias vezes enquanto escrevia este artigo é o quão *simples* os computadores são. Ainda é difícil que eu não pire, esperando mais complexidade ou abstração do que realmente existe! Se tem alguma coisa que você deveria guardar em seu cérebro antes de continuar, é que tudo que parece simples na verdade é realmente simples. Essa simplicidade é bem bonita e por vezes muito, muito amaldiçoada.

<!-- Let's start with the basics of how your computer works at its very core. -->

Vamos começar pelo básico de como seu computador funciona pelo seu núcleo.

<!-- ## How Computers Are Architected -->

## Como os computadores são arquitetados

<!-- The *central processing unit* (CPU) of a computer is in charge of all computation. It's the big cheese. The shazam alakablam. It starts chugging as soon as you start your computer, executing instruction after instruction after instruction. -->

A unidade de controle central (em inglês, *central processing unit*, ou CPU) de um computador é responsável por todas as computações. É o chefão. O manda chuva. Ela começa a rodar assim que você liga seu computador, executando instrução após instrução após instrução.

<!-- The first mass-produced CPU was the [Intel 4004](http://www.intel4004.com/), designed in the late 60s by an Italian physicist and engineer named Federico Faggin. It was a 4-bit architecture instead of the [64-bit](https://en.wikipedia.org/wiki/64-bit_computing) systems we use today, and it was far less complex than modern processors, but a lot of its simplicity does still remain. -->

A primeira CPU feita em massa foi o [Intel 4004](http://www.intel4004.com/), projetada no fim dos anos 60 por um físico e engenheiro italiano chamado Federico Faggin. Ela tinha uma arquitetura de 4 bits em vez dos [64 bits](https://en.wikipedia.org/wiki/64-bit_computing) que usamos hoje, e ela era bem menos complexa que processadores modernos, mas muito de sua simplicidade ainda existe.

<!-- The "instructions" that CPUs execute are just binary data: a byte or two to represent what instruction is being run (the opcode), followed by whatever data is needed to run the instruction. What we call *machine code* is nothing but a series of these binary instructions in a row. [Assembly](https://en.wikipedia.org/wiki/Assembly_language) is a helpful syntax for reading and writing machine code that's easier for humans to read and write than raw bits; it is always compiled to the binary that your CPU knows how to read. -->

As instru;'oes que as CPUs executam são apenas dados binários: um byte ou dois representam qual instrução está sendo executada (o opcode), seguida de quaisquer dados que sejam necessários para executar essa instrução. O que chamamos de *código de máquina* não é nada além de uma série dessas instruções binárias em sequência. A linguagem [Assembly](https://en.wikipedia.org/wiki/Assembly_language) é uma sintaxe que ajuda a ler e escrever código que sejam mais fáceis de serem lidos e escritos por humanos que apenas bits; ela é sempre compilada para o binário que a sua CPU sabe como ler.

<!-- <img src='/images/assembly-to-machine-code-translation.png' loading='eager' style='max-width: 400px;' alt='A diagram demonstrating how machine code translates to assembly and back. A bidirectional arrow connects three examples: Machine Code (Binary) followed by 3 bytes of binary numbers, Machine Code (Hex) followed by those 3 bytes translated to hex (0x83, 0xC3, 0x0A), and Assembly followed by "add ebx, 10". The Assembly and Machine Code are color-coded so it is clear that each byte of the machine code translate to one word in the assembly.' width='935' height='505' /> -->

<img src='/images/assembly-to-machine-code-translation.png' loading='eager' style='max-width: 400px;' alt='Um diagrama demonstrando como código de máquina é traduzido para assembly e vice-versa. Uma seta bidirecional conecta três exemplos: código de máquina (binário) seguido de 3 bytes de números binários, código de máquina (hexadecimal) seguido desses 3 bytes traduzidos para hexadecimal (0x83, 0xC3, x0A) e Assembly seguido de "add ebx, 10". O código assembly e o código de máquina são coloridos de forma que é claro que cada byte de cada código de máquina é traduzido para uma palavra em Assembly.' width='935' height='505' />

<!-- > An aside: instructions aren't always represented 1:1 in machine code as in the above example. For example, `add eax, 512` translates to `05 00 02 00 00`. -->
<!-- >  -->
<!-- > The first byte (`05`) is an opcode specifically representing *adding the EAX register to a 32-bit number*. The remaining bytes are 512 (`0x200`) in [little-endian](https://en.wikipedia.org/wiki/Endianness) byte order. -->
<!-- > -->
<!-- > Defuse Security created [a helpful tool](https://defuse.ca/online-x86-assembler.htm) for playing around with the translation between assembly and machine code. -->

> Uma observação: instruções não são sempre representadas de um para um para o código de máquina como exemplo acima. Por exemplo, `add eax, 512` é traduzido para `05 00 02 00 00`.
> 
> O primeiro byte (`05`) é um opcode representando especificamente *adicionar o registrador EAX para um número de 32 bits*. Os bytes remanescentes são 512 (`0x200`) na ordem de bytes [little-endian](https://en.wikipedia.org/wiki/Endianness)
>
> Defuse Security criou [uma ferramenta](https://defuse.ca/online-x86-assembler.htm) que ajuda bastante para brincar com a tradução entre Assembly e código de máquina.

<!-- RAM is your computer's main memory bank, a large multi-purpose space which stores all the data used by programs running on your computer. That includes the program code itself as well as the code at the core of the operating system. The CPU always reads machine code directly from RAM, and code can't be run if it isn't loaded into RAM. -->

A RAM é o principal banco de memória do seu computador, um grande espaço para vários propósitos que guarda todos os dados usados por programas sendo executados em seu computador. Isso inclui o próprio código do programa bem como o código no núcleo do sistema operacional. A CPU sempre lê código de máquina diretamente da RAM, e o código não pode ser executado se não foi carregado na RAM.

<!-- The CPU stores an *instruction pointer* which points to the location in RAM where it's going to fetch the next instruction. After executing each instruction, the CPU moves the pointer and repeats. This is the *fetch-execute cycle*. -->

A CPU armazena um *apontador de instrução* (em inglês, *instruction pointer*), que aponta para a localização na RAM onde ela vai buscar a próxima instrução. Após executar cada instrução, a CPU move esse apontador e repete. Esse é o ciclo *busca-executa* (em inglês *fetch-execute  cycle*).

<!-- <img src='/images/fetch-execute-cycle.png' loading='lazy' style='max-width: 360px; margin: 0 auto;' alt='A diagram demonstrating the fetch-execute cycle. There are two bubbles of text. The first is labeled "Fetch" and has the text "Read instruction from memory at the current instruction pointer." The second is titled "Execute" and has the text "Run the instruction and then move the instruction pointer." The fetch bubble has an arrow pointing to the execute bubble, and the execute bubble has an arrow pointing back to the fetch bubble, implying a repeated process.' width='848' height='458' /> -->

<img src='/images/fetch-execute-cycle.png' loading='lazy' style='max-width: 360px; margin: 0 auto;' alt='Um diagrama mostrando o ciclo busca-executa. Há dois balões de texto. O primeiro é rotulado "Busca" e tem um texto "Lê a instrução da memória no apontador de instrução atual." O segundo é rotulado "Executa" e tem o texto "Executa a instrução e então move o apontador de instrução". O balão "Busca" tem uma seta apontando par o balão "Executa" e o balão "Executa" tem uma seta apontando de volta para o balão "Busca", implicando um processo que se repete.' width='848' height='458' />

<!-- After executing an instruction, the pointer moves forward to immediately after the instruction in RAM so that it now points to the next instruction. That's why code runs! The instruction pointer just keeps chugging forward, executing machine code in the order in which it has been stored in memory. Some instructions can tell the instruction pointer to jump somewhere else instead, or jump different places depending on a certain condition; this makes reusable code and conditional logic possible. -->

Após executar uma instrução, o apontador se move para a frente imediatamente após a instrução na RAM de forma que agora aponta para a próxima instrução. É por isso que o código executa! O ponteiro de instrução apenas se move para a frente, executando o código de máquina na ordem que foi armazenado na memória. Algumas instruções podem dizer ao ponteiro de instrução para pular para outro lugar, ou pular para diferentes lugares dependendo de uma certa condição; isso torna o reúso de código e a lógica condicional possivel.

<!-- This instruction pointer is stored in a [*register*](https://en.wikipedia.org/wiki/Processor_register). Registers are small storage buckets that are extremely fast for the CPU to read and write to. Each CPU architecture has a fixed set of registers, used for everything from storing temporary values during computations to configuring the processor. -->

Esse apontador de instrução é armazenado em um [*registrador*](https://en.wikipedia.org/wiki/Processor_register). Registradores são pequenos espaços de armazenamento que são extremamente rápidos para a CPU ler e escrever. Cada arquitetura de CPU tem um conjunto fixo de registradores, usados para tudo desde guardar valores temporários durante computações até configurar o processador.

<!-- Some registers are directly accessible from machine code, like `ebx` in the earlier diagram. -->

Alguns registradores são diretamente acessíveis pelo código de máquina, como o `ebx` no diagrama anterior.

<!-- Other registers are only used internally by the CPU, but can often be updated or read using specialized instructions. One example is the instruction pointer, which can't be read directly but can be updated with, for example, a jump instruction. -->

Outros registradores são apenas usados internamente pela CPU, mas podem ser atualizados ou lidos usando instruções especializadas. Um exemplo é o apontador de instrução, que não pode ser lido diretamente mas pode ser atualizado, por exemplo, com uma instrução de salto (em inglês, `jump instruction`).

<!-- ## Processors Are Naive -->

## Processadores são inocentes

<!-- Let's go back to the original question: what happens when you run an executable program on your computer? First, a bunch of magic happens to get ready to run it — we’ll work through all of this later — but at the end of the process there’s machine code in a file somewhere. The operating system loads this into RAM and instructs the CPU to jump the instruction pointer to that position in RAM. The CPU continues running its fetch-execute cycle as usual, so the program begins executing! -->

Vamos voltar para a questão original: o que acontece quando você executa um programa em seu computador? A princípio, um monte de mágica acontece para prepará-lo para ser executado - nós vamos falar disso depois - mas no fim desse processo temos código de máquina em um arquivo em algum lugar. O sistema operacional vai carregar isso para a RAM e diz para a CPU para mover o apontador de instrução para essa posição na RAM. A CPU continua executando o ciclo busca-executa como sempre, então o programa começa a ser executado!

<!-- (This was one of those psyching-myself-out moments for me — seriously, this is how the program you are using to read this article is running! Your CPU is fetching your browser's instructions from RAM in sequence and directly executing them, and they're rendering this article.) -->

(Essa foi uma dos momentos que me fez pirar - sério, é assim que o programa que você está usando para ler este artigo é executado! Sua CPU está buscando as instruções do seu navegador na RAM em sequência e diretamente as executando, e elas estão renderizando este artigo.)

<!-- <img src='/images/instruction-pointer.png' loading='lazy' style='max-width: 400px;' alt='A diagram depicting a series of bytes of machine code in RAM. A highlighted byte is pointed to by an arrow labeled "Instruction Pointer," and there are arrows representing how the instruction pointer moves forward in RAM.' width='935' height='372' /> -->

<img src='/images/instruction-pointer.png' loading='lazy' style='max-width: 400px;' alt='Um diagrama mostrando uma série de bytes de código de máquina na RAM. Um byte destacado é apontado por uma seta rotulada "Apontador de Instrução", e há setas representando como um apontador de instrução se move para a frente na RAM.' width='935' height='372' />

It turns out CPUs have a super basic worldview; they only see the current instruction pointer and a bit of internal state. Processes are entirely operating system abstractions, not something CPUs natively understand or keep track of.

<!-- *\*waves hands\* processes are abstractions made up by ~~os devs~~ big byte to sell more computers* -->

*\*papo furado\* processos são abstrações feitas pelos ~~desenvolvedores de sistemas operacionais~~ grandes empresas para vender mais computadores *

<!-- For me, this raises more questions than it answers: -->

Para mim, isso levanta mais questçoes do que responde:

<!-- 1. If the CPU doesn’t know about multiprocessing and just executes instructions sequentially, why doesn’t it get stuck inside whatever program it’s running? How can multiple programs run at once? -->

1. Se a CPU não sabe nada sobre multiprocessamento e apenas executa instruções sequencialmente, por que não fica presa dentro programa que está executando? Como múltiplos programas podem ser executados ao mesmo tempo?

<!-- 2. If programs run directly on the CPU, and the CPU can directly access RAM, why can't code access memory from other processes, or, god forbid, the kernel? -->

2. Se um programa é executado diretamente pela CPU, e a CPU pode acessar diretamente a RAM, por que um código não pode acessar a memória de outros processos, ou (pelo amor, perdão), o kernel?

<!-- 3. Speaking of which, what's the mechanism that prevents every process from running any instruction and doing anything to your computer? AND WHAT'S A DAMN SYSCALL? -->

3. Falando nisso, qual é o mecanismo que previne que cada processo execute qualquer execução? E QUE DIABOS É UMA SYSCALL?

<!-- The question about memory deserves its own section and is covered in [chapter 5](/the-translator-in-your-computer) — the TL;DR is that most memory accesses actually go through a layer of misdirection that remaps the entire address space. For now, we're going to pretend that programs can access all RAM directly and computers can only run one process at once. We'll explain away both of these assumptions in time. -->

A questão sobre memória merece sua própria seção e está coberta no [capítulo 5](/the-translator-in-your-computer) — um TL;DR é que a maior parte dos acessos à memória na verdade vão através de uma camada de direcionamento que remapeia todo o espaço de endereço. Por enquanto, vamos fingir que o programa pode acessar toda a RAM diretamente e que os computadores podem executar apenas um processo por vez. Vamos explicar essas suposições depois.

<!-- It's time to leap through our first rabbit hole into a land filled with syscalls and security rings. -->

É hora de entrarmos no primeiro buraco de coelho rumo a uma terra lotada de syscalls e anéis de segurança.

<!-- > **Aside: what is a kernel, btw?** -->
<!-- >  -->
<!-- > Your computer's operating system, like macOS, Windows, or Linux, is the collection of software that runs on your computer and makes all the basic stuff work. "Basic stuff" is a really general term, and so is "operating system" — depending on who you ask, it can include such things as the apps, fonts, and icons that come with your computer by default. -->
<!-- >  -->
<!-- > The kernel, however, is the core of the operating system. When you boot up your computer, the instruction pointer starts at a program somewhere. That program is the kernel. The kernel has near-full access to your computer's memory, peripherals, and other resources, and is in charge of running software installed on your computer (known as userland programs). We'll learn about how the kernel has this access — and how userland programs don't — over the course of this article. -->
<!-- > -->
<!-- > Linux is just a kernel and needs plenty of userland software like shells and display servers to be usable. The kernel in macOS is called [XNU](https://en.wikipedia.org/wiki/XNU) and is Unix-like, and the modern Windows kernel is called the [NT Kernel](https://en.wikipedia.org/wiki/Architecture_of_Windows_NT). -->

> **Observação: afinal, o que é um kernel?**
> 
> O sistema operacional de seu computador, como o macOS, Windows ou Linux, é a coleção de software que executa em seu computador e faz todo o trabalho básico. "Trabalho básico" é realmente um termo genérico, da mesma forma que "sistema operacional" - dependendo a quem você pergunta, isso pode incluir coisas como apps, fontes, e ícones que vêm com seu computador por padrão.
> 
> O kernel, porém, é o núcleo do sistema operacional. Quando você liga seu computador, o apontador de instrução começa em um programa em algum lugar. Esse programa é o kernel. O kernel tem quase total acesso à memória de seu computador, periféricos e outros recursos, e é responsável por executar software instalado em seu computador (conhecido como programas de espaço de usuário, ou *userland* em inglês). Vamos falar como o kernel tem esse acesso - e como programas do espaço de usuário não têm - conforme avançamos neste artigo.
>
> Linux é apenas uma kernel, e precisa de vários programas de espaço de usuário como shells e servidores gráficos para ser usuárvel. O kernel do macOS é chamado [XNU](https://en.wikipedia.org/wiki/XNU) e é Unix-like, e o kernel do Windows moderno é chamado [NT Kernel](https://en.wikipedia.org/wiki/Architecture_of_Windows_NT)

<!-- ## Two Rings to Rule Them All -->

## Dois anéis para todos governar

<!-- The *mode* (sometimes called privilege level or ring) a processor is in controls what it's allowed to do. Modern architectures have at least two options: kernel/supervisor mode and user mode. While an architecture might support more than two modes, only kernel mode and user mode are commonly used these days. -->

O *modo* (as vezes chamado nível de privilégio ou anel) que processador está controla o que é permitido fazer. Arquiteturas modernas tem ao menos duas opções: modo de kernel/superviosr e modo de usuário. Enquanto uma arquitetura pode suportar mais que dois modos, apenas o modo de kernel e o de usuário são usados atualmente.

<!-- In kernel mode, anything goes: the CPU is allowed to execute any supported instruction and access any memory. In user mode, only a subset of instructions is allowed, I/O and memory access is limited, and many CPU settings are locked. Generally, the kernel and drivers run in kernel mode while applications run in user mode. -->

No modo de kernel, tudo pode acontecer: a CPU tem a permissão de executar qualquer instrução suportada e acessar qualquer memória. No modo de usuário, apenas um subconjunto de instruções é permitido, entrada, saída e memória são limitados, e várias configurações da CPU são travadas. Geralmente, o kernel e os drivers são executadas em modo de kernel enquanto aplicações são executadas em modo de usuário.

<!-- Processors start in kernel mode. Before executing a program, the kernel initiates the switch to user mode. -->

Processadores começam no modo de kernel. Antes de executar um programa, o kernel inicia a transição para o o modo de usuário.

<!-- <img src='/images/kernel-mode-vs-user-mode.png' loading='lazy' style='max-width: 500px; margin: 0 auto;' alt='Two fake iMessage screenshots demonstrating the different between user and kernel mode protections. The first, labeled Kernel Mode: right side says "Read this protected memory!", left side replies "Here you go, dear :)". The second, labeled User Mode: right side says "Read this protected memory!", left side replies "No! Segmentation fault!"' width='1072' height='433' /> -->

<img src='/images/kernel-mode-vs-user-mode.png' loading='lazy' style='max-width: 500px; margin: 0 auto;' alt='Dois screenshots falsos do WhatsApp demonstrando a diferença entre o modo de usuário e o modo de usuário. O primeiro, rotulado "Modo de Kernel": o lado direito diz "Leia essa memória protegida!", o lado esquerdo diz "aqui está, meu caro :-)". O segundo, rotulado "modo de usuário": o lado direito diz: "Leia essa memória protegida!!", o lado esquerdo responde: "Não! Segmentation fault!"' width='1072' height='433' />


<!-- An example of how processor modes manifest in a real architecture: on x86-64, the current privilege level (CPL) can be read from a register called `cs` (code segment). Specifically, the CPL is contained in the two [least significant bits](https://en.wikipedia.org/wiki/Bit_numbering) of the `cs` register. Those two bits can store x86-64's four possible rings: ring 0 is kernel mode and ring 3 is user mode. Rings 1 and 2 are designed for running drivers but are only used by a handful of older niche operating systems. If the CPL bits are `11`, for example, the CPU is running in ring 3: user mode. -->

Um exemplo de como os modos do processador se manifestam em uma arquitetura real: no x86-64, o nível de privilégio atual (em inglês, *current privilege level (CPL)*) pode ser lido de um registrador chamado `cs` (*code segment*). Especificamente, o CPL fica nos [bits menos significantes](https://en.wikipedia.org/wiki/Bit_numbering) do registrador `cs`. Esses dois bits podem ser armazenar até quatro possiveis anéis do x86-64: anel 0 é o modo de kernel e anel 3 é o modo de usuário. Os anéis 1 e 2 são feitos para executar drivers mas são só usados por alguns sistemas operacionais mais velhos e de nicho. Se os bits do CPL são `11`, por exemplo, a CPU está executando no anel 3: modo de usuário.

<!-- ## What Even is a Syscall? -->

## O que é mesmo uma sycall?

<!-- Programs run in user mode because they can't be trusted with full access to the computer. User mode does its job, preventing access to most of the computer — but programs need to be able to access I/O, allocate memory, and interact with the operating system *somehow*! To do so, software running in user mode has to ask the operating system kernel for help. The OS can then implement its own security protections to prevent programs from doing anything malicious. -->

Programas são executados em modo de usuário porque não podemos confiar a eles o total acesso ao computador. O modo de usuário faz esse serviço, prevenindo o acesso à maior parte do computador - mas programas precisam ser capazes de acessar a entrada e saída, alocar memória e interagir com sistema operacional *de alguma forma*! Para fazer isso, o software que é executado no modo de usuário precisa pedir ajuda para o sistema operacional. O sistema operacional pode então implementar suas próprias proteções para prevenir que os programas façam alguma coisa maliciosa.

<!-- If you've ever written code that interacts with the OS, you'll probably recognize functions like `open`, `read`, `fork`, and `exit`. Below a couple of layers of abstraction, these functions all use *system calls* to ask the OS for help. A system call is a special procedure that lets a program start a transition from user space to kernel space, jumping from the program's code into OS code. -->

Se você alguma vez já escreveu código que interage com o sistema operacional, então provavelmente você reconhece funções como `open`, `read`, `fork` e `exit`. Debaixo de um monte de camadas de abstração, todas essas funções usam *chamadas de sistema* (em inglês, *system call*, ou *syscall*) para pedir ajuda para o sistema operacional. Uma chamada de sistema é um procedimento especial que permite que um programa inicie a transição do espaço de usuário para o espaço de kernel, saltando do código do programa para o código do OS.

<!-- User space to kernel space control transfers are accomplished using a processor feature called [*software interrupts*](https://en.wikipedia.org/wiki/Interrupt#Software_interrupts): -->

Transferências do espaço de usuário para o espaço de kernel são feitas usando um recurso do processador chamado [*interrupções de software*](https://en.wikipedia.org/wiki/Interrupt#Software_interrupts):

<!-- 1. During the boot process, the operating system stores a table called an [*interrupt vector table*](https://en.wikipedia.org/wiki/Interrupt_vector_table) (IVT; x86-64 calls this the [interrupt descriptor table](https://en.wikipedia.org/wiki/Interrupt_descriptor_table)) in RAM and registers it with the CPU. The IVT maps interrupt numbers to handler code pointers. -->

1. Durante o processo de boot, o sistema operacional guarda uma tabela chamada [*tabela de vetor de interrupções*](https://en.wikipedia.org/wiki/Interrupt_vector_table) (em inglês, *interrupt vector table* ou IVT; x86-64 chama isso de [tabela de descritores de interrupção](https://en.wikipedia.org/wiki/Interrupt_descriptor_table), *interrupt descriptor table*).

  <!-- <img src='/images/interrupt-vector-table.png' loading='lazy' style='max-width: 300px; margin: 0 auto;' alt='A image of a table captioned "Interrupt Vector Table". The first column, labeled with a number sign, has a series of numbers starting at 01 and going to 04. The corresponding second column of the table, labeled "Handler Address", contains a random 8-byte-long hex number per entry. The bottom of the table has the text "So on and such forth..."' width='555' height='463' /> -->

  <img src='/images/interrupt-vector-table.png' loading='lazy' style='max-width: 300px; margin: 0 auto;' alt='Uma imagem de uma tabela com a legenda "Interrupt Vector Table". A primeira coluna, rotulada com um sinal de numero, tem uma série de numeros iniciando em 01 e indo até 04. A segunda coluna correspondente, rotulada "Endereço da rotina", contém um número hexadecimal aleatório de 8 bytes por entrada. A parte de baixo da tabela tem o texto "e assim por diante"' width='555' height='463' />

<!-- 2. Then, userland programs can use an instruction like [INT](https://www.felixcloutier.com/x86/intn:into:int3:int1) which tells the processor to look up the given interrupt number in the IVT, switch to kernel mode, and then jump the instruction pointer to the memory address stored in the IVT. -->

2. Então, os programas de espaço de usuário podem usar instruções como [INT](https://www.felixcloutier.com/x86/intn:into:int3:int1) que diz ao processador para procurar o número da interrupção dado na IVT, mudar para o modo de kernel e então alterar o apontador de instrução para o endereço de memória armazenado na IVT.

<!-- When this kernel code finishes, it uses an instruction like [IRET](https://www.felixcloutier.com/x86/iret:iretd:iretq) to tell the CPU to switch back to user mode and return the instruction pointer to where it was when the interrupt was triggered. -->

Quando o código do kernel termina, ele usa uma instrução como [IRET](https://www.felixcloutier.com/x86/iret:iretd:iretq) para dizer à CPU para voltar para o modo de usuário e voltar o apontador de instrução para onde ele estava quando a interrução foi chamada.

<!-- (If you were curious, the interrupt ID used for system calls on Linux is `0x80`. You can read a list of Linux system calls on [Michael Kerrisk's online manpage directory](https://man7.org/linux/man-pages/man2/syscalls.2.html).) -->

(Se você tem curiosidade, o identificador de interruções para chamadas de sistema no Linux é `0x80`. Você pode ver uma lista de chamadas de sistema do Linux no [diretório online de manpages de Michael Kerrisk](https://man7.org/linux/man-pages/man2/syscalls.2.html).)

<!-- ### Wrapper APIs: Abstracting Away Interrupts -->

### Wrapper APIs: abstraindo as interrupções

<!-- Here's what we know so far about system calls: -->

Aqui está o que sabemos por enquanto sobre chamadas de sistemas:

<!-- - User mode programs can't access I/O or memory directly. They have to ask the OS for help interacting with the outside world. -->
<!-- - Programs can delegate control to the OS with special machine code instructions like INT and IRET. -->
<!-- - Programs can't directly switch privilege levels; software interrupts are safe because the processor has been preconfigured *by the OS* with where in the OS code to jump to. The interrupt vector table can only be configured from kernel mode. -->

- Programas no modo de usuário não podem acessar a entrada e saída ou a memória diretamente. Elas precisam ajuda pedir para o sistema operacional para interagir com o mundo de fora
- Programas podem delegar controle para o sistema operacional com instruções de código de máquina especiais como INT e IRET.
- Programas não podem trocar de níveis de privilégio diretamente; interrupções de software são seguras porque o processador foi pré-configurado *pelo sistema operacional* com o endereço no código do sistema operacional para onde o deve saltar. A tabela de vetor de interrupções só pode ser configurada pelo modo de kernel.

<!-- Programs need to pass data to the operating system when triggering a syscall; the OS needs to know which specific system call to execute alongside any data the syscall itself needs, for example, what filename to open. The mechanism for passing this data varies by operating system and architecture, but it's usually done by placing data in certain registers or on the stack before triggering the interrupt. -->

Programas precisam passar dados para o sistema operacional quando fizerem uma chamada de sistema; o sistema operacional precisa saber qual syscall específica executar junto dos dados que são necessários para a própria syscall, por exemplo, qual o nome do arquivo que vai ser aberto. O mecanismo para passar esses dados varia entre os sistemas operacionais e as arquiteturas, porém, normalmente isso é feito colocando dados em certos registradores ou na pilha antes de chamar a interrupção.

<!-- The variance in how system calls are called across devices means it would be wildly impractical for programmers to implement system calls themselves for every program. This would also mean operating systems couldn't change their interrupt handling for fear of breaking every program that was written to use the old system. Finally, we typically don't write programs in raw assembly anymore — programmers can't be expected to drop down to assembly any time they want to read a file or allocate memory. -->

A diferença na forma como chamadas de sistemas são feitas significa que é praticamente impossível para programadores implementá-las sozinhos para cada programa. Isso também significaria que os sistemas operacionais não poderiam mudar a forma como tratam as interrupções com medo de quebrar cada programa que foi feito para ser usado pelo sistema antigo. Por fim, normalmente não escrevemos mais códigos em assembly - não podemos esperar que programadores mergulhem no assembly toda vez que precisarem escrever um arquivo ou alocar memória.

<!-- <img src='/images/syscall-architecture-differences.png' loading='lazy' style='max-width: 650px; margin: 0 auto;' alt='A drawing captioned "System calls are implemented differently across architectures." On the left is a smiling CPU receiving some binary and spitting out a filename, file.txt. Separated on the right is a different CPU receiving the same binary data but with a confused and nauseous facial expression.' width='1057' height='360' /> -->
<img src='/images/syscall-architecture-differences.png' loading='lazy' style='max-width: 650px; margin: 0 auto;' alt='Um desenho com a legenda "Chamadas de sistema são implementadas de diferentes formas em diferentes arquiteturas". Na esquerda tem uma CPU sorridente recebendo um binário e cuspindo um nome de arquivo, file.txt. Separado, na direita tem uma outra CPU recebendo o mesmo binário mas confuso e com expressão de náusea.' width='1057' height='360' />

<!-- So, operating systems provide an abstraction layer on top of these interrupts. Reusable higher-level library functions that wrap the necessary assembly instructions are provided by [libc](https://www.gnu.org/software/libc/) on Unix-like systems and part of a library called [ntdll.dll](https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/libraries-and-headers) on Windows. Calls to these library functions themselves don't cause switches to kernel mode, they're just standard function calls. Inside the libraries, assembly code does actually transfer control to the kernel, and is a lot more platform-dependent than the wrapping library subroutine. -->

Então, sistemas operacionais provêem uma camada de abstração no topo dessas interrupções. Funções de biblioteca de mais alto nível reusáveis que encapsulam as instruções assembly necessárias são fornecidas pela [libc](https://www.gnu.org/software/libc/) em sistemas Unix-like e parte da biblioteca chamada [ntdll.dll](https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/libraries-and-headers) no Windows. Chamadas para essas funções por si só não causam trocas no modo do kernel, elas são só chamadas de funções normais. Dentro dessas bibliotecas há códigos assembly que de fato transferem o controle para o kernel, e que são muito mais dependentes da plataforma que a subrotina da biblioteca que os encapsula.

<!-- When you call `exit(1)` from C running on a Unix-like system, that function is internally running machine code to trigger an interrupt, after placing the system call's opcode and arguments in the right registers/stack/whatever. Computers are so cool! -->

Quando você chama `exit(1)`  de um código C rodando de um sistema Unix-like, essa função internamente chama código de máquina para iniciar uma interrupção, depois de colocar o opcode da chamada de sistema nos registrador/pilha/seja la o que corretos. Computadores são tão legais!

<!-- ## The Need for Speed / Let's Get CISC-y -->

## A demanda por velocidade / processadores CISC

<!-- Many [CISC](https://en.wikipedia.org/wiki/Complex_instruction_set_computer) architectures like x86-64 contain instructions designed for system calls, created due to the prevalence of the system call paradigm. -->

Várias arquiteturas [CISC](https://en.wikipedia.org/wiki/Complex_instruction_set_computer) como x86-64 contém instruções feitas para chamadas de sistemas, criadas por conta da prevalência do paradigma de chamadas de sistema.

<!-- Intel and AMD managed not to coordinate very well on x86-64; it actually has *two* sets of optimized system call instructions. [SYSCALL](https://www.felixcloutier.com/x86/syscall.html) and [SYSENTER](https://www.felixcloutier.com/x86/sysenter) are optimized alternatives to instructions like `INT 0x80`. Their corresponding return instructions, [SYSRET](https://www.felixcloutier.com/x86/sysret.html) and [SYSEXIT](https://www.felixcloutier.com/x86/sysexit), are designed to transition quickly back to user space and resume program code. -->

A Intel e a AMD não se coordenam muito bem no x86-64; na verdade há *dois* conjuntos de instruções de chamada de sistema otimizadas. [SYSCALL](https://www.felixcloutier.com/x86/syscall.html) e [SYSENTER](https://www.felixcloutier.com/x86/sysenter) são alternativas otimizadas para instruções como `INT 0x80`. Suas instruções de retorno correspondente, [SYSRET](https://www.felixcloutier.com/x86/sysret.html) e [SYSEXIT](https://www.felixcloutier.com/x86/sysexit), foram feitas para transicionar rapidamente para o espaço de usuário e continuar a execução do programa.

<!-- (AMD and Intel processors have slightly different compatibility with these instructions. `SYSCALL` is generally the best option for 64-bit programs, while `SYSENTER` has better support with 32-bit programs.) -->

(Processadores AMD e Intel têm diferentes compatibilidades para essas instruções. `SYSCALL` é geralmente a melhor opção para programas em 64-bit, enquanto que `SYSENTER` tem melhor suporte em programas em 32-bit.)

<!-- Representative of the style, [RISC](https://en.wikipedia.org/wiki/Reduced_instruction_set_computer) architectures tend not to have such special instructions. AArch64, the RISC architecture Apple Silicon is based on, uses only [one interrupt instruction](https://developer.arm.com/documentation/ddi0596/2021-12/Base-Instructions/SVC--Supervisor-Call-) for syscalls and software interrupts alike. I think Mac users are doing fine&nbsp;:) -->

Arquiteturas [RISC](https://en.wikipedia.org/wiki/Reduced_instruction_set_computer) tendem a não ter instruçoes especiais. A AArch64, a arquitetura RISC em que o Apple Silicon é baseado, usa apenas [uma instrução de interrupção](https://developer.arm.com/documentation/ddi0596/2021-12/Base-Instructions/SVC--Supervisor-Call-) para syscalls e interrupções de software. Eu acho que usuários de Mac passam bem&nbsp;:)

---

<!-- Whew, that was a lot! Let's do a brief recap: -->

Ufa, foi coisa pra caramba! Vamos dar uma recapitulada:

<!-- - Processors execute instructions in an infinite fetch-execute loop and don't have any concept of operating systems or programs. The processor's mode, usually stored in a register, determines what instructions may be executed. Operating system code runs in kernel mode and switches to user mode to run programs. -->
<!-- - To run a binary, the operating system switches to user mode and points the processor to the code's entry point in RAM. Because they only have the privileges of user mode, programs that want to interact with the world need to jump to OS code for help. System calls are a standardized way for programs to switch from user mode to kernel mode and into OS code. -->
<!-- - Programs typically use these syscalls by calling shared library functions. These wrap machine code for either software interrupts or architecture-specific syscall instructions that transfer control to the OS kernel and switch rings. The kernel does its business and switches back to user mode and returns to the program code. -->

- Processadores executam instruções em um ciclo infinito de busca e execução e não têm nenhum conceito de sistemas operacionais ou programas. O modo do processador, normalmente armazenado em um registrador, determina quais instruções devem ser executadas. O código do sistema operacional é executado em modo kernel e muda para o modo de usuário para executar programas.
- Para executar um binário, o sistema operacional muda para o modo de usuário e faz o processador apontar para o endereço do código na RAM. Como eles só têm o privilégio do modo de usuário, programas que precisam interagir com o mundo precisam pedir ajuda para o sistema operacional. Chamadas de sistema são uma forma padronizada de programas mudarem do modo de usuário para o modo de kernel e para dentro do código do sistema operacional.
- Programas tipicamente usam essas sycalls chamando funções de bibliotecas compartilhadas. Elas encapsulam o código de máquina para interrupções de software ou syscalls específicas de cada arquitetura que transferem o controle para o kernel do sistema operacional e mudam os anéis. O kernel faz seu trabalho, troca para o modo de usuário e volta para o código do programa.


<!-- Let’s figure out how to answer my first question from earlier: -->

Vamos tentar ver como podemos responder minha pergunta de antes:

<!-- > If the CPU doesn't keep track of more than one process and just executes instruction after instruction, why doesn't it get stuck inside whatever program it's running? How can multiple programs run at once? -->

> Se a CPU não toma conta de mais de um processo e apenas executa instrução após instrução, por que ela não fica presa dentro de seja lá qual programa ela está executando? Como múltiplos programas rodam ao mesmo tempo?

<!-- The answer to this, my dear friend, is also the answer to why Coldplay is so popular... clocks! (Well, technically timers. I just wanted to shoehorn that joke in.) -->

A resposta para isso, meu amigo, é a mesma resposta de por que o Coldplay é tão popular... clocks! (Bem, tecnicamente, temporizadores. Só queria jogar essa piada aqui.)
